# coding=utf-8
import cv2
import numpy as np
import mvsdk
import platform
import datetime
import time

def main_loop():
    # 枚举相机
    DevList = mvsdk.CameraEnumerateDevice()
    nDev = len(DevList)
    if nDev < 1:
        print("No camera was found!")
        return

    for i, DevInfo in enumerate(DevList):
        print("{}: {} {}".format(i, DevInfo.GetFriendlyName(), DevInfo.GetPortType()))
    i = 0 if nDev == 1 else int(input("Select camera: "))
    DevInfo = DevList[i]
    print(DevInfo)

    # 打开相机
    hCamera = 0
    try:
        hCamera = mvsdk.CameraInit(DevInfo, -1, -1)
    except mvsdk.CameraException as e:
        print("CameraInit Failed({}): {}".format(e.error_code, e.message))
        return

    # 获取相机特性描述
    cap = mvsdk.CameraGetCapability(hCamera)

    # 判断是黑白相机还是彩色相机
    monoCamera = (cap.sIspCapacity.bMonoSensor != 0)

    # 黑白相机让ISP直接输出MONO数据
    if monoCamera:
        mvsdk.CameraSetIspOutFormat(hCamera, mvsdk.CAMERA_MEDIA_TYPE_MONO8)
    else:
        mvsdk.CameraSetIspOutFormat(hCamera, mvsdk.CAMERA_MEDIA_TYPE_BGR8)

    # 相机模式切换成连续采集
    mvsdk.CameraSetTriggerMode(hCamera, 0)

    # 自动曝光配置
    mvsdk.CameraSetAeState(hCamera, 1)
    mvsdk.CameraSetOnceWB(hCamera)

    # 让SDK内部取图线程开始工作
    mvsdk.CameraPlay(hCamera)

    # 计算buffer大小
    FrameBufferSize = cap.sResolutionRange.iWidthMax * \
        cap.sResolutionRange.iHeightMax * (1 if monoCamera else 3)

    # 分配RGB buffer
    pFrameBuffer = mvsdk.CameraAlignMalloc(FrameBufferSize, 16)

    # ==================== 录像相关变量 ====================
    is_recording = False            # 是否正在录制
    use_sdk_record = False          # 标记当前使用的是SDK录像还是OpenCV录像
    video_writer = None             # OpenCV视频写入对象
    output_filename = ""
    
    # ==================== 帧率计算 ====================
    fps_counter = 0
    fps_start_time = time.time()
    current_fps = 0
    
    # 显示设置
    DISPLAY_SIZE = (800, 600)

    while (cv2.waitKey(1) & 0xFF) != ord('q'):
        try:
            # 1. 获取原始Raw数据
            pRawData, FrameHead = mvsdk.CameraGetImageBuffer(hCamera, 200)
            
            # 2. 处理Raw数据到RGB Buffer
            mvsdk.CameraImageProcess(hCamera, pRawData, pFrameBuffer, FrameHead)
            
            # 3. 释放Raw数据Buffer
            mvsdk.CameraReleaseImageBuffer(hCamera, pRawData)

            # ==================== 核心录像逻辑 ====================
            if is_recording:
                if use_sdk_record:
                    # SDK 录像模式：直接压入SDK队列
                    mvsdk.CameraPushFrame(hCamera, pFrameBuffer, FrameHead)
                elif video_writer is not None:
                    # OpenCV 录像模式：需要从Buffer转成Numpy数组
                    # 注意：为了性能，这里重复利用下面的 frame_data 转换逻辑
                    # 但由于OpenCV写入需要BGR格式（SDK默认处理出来通常是BGR，无需转换）
                    
                    # 将 ctypes 指针转换为 numpy 数组
                    frame_data = (mvsdk.c_ubyte * FrameHead.uBytes).from_address(pFrameBuffer)
                    # 这是一个耗时操作，但在Linux上必须这样做才能录像
                    record_frame = np.frombuffer(frame_data, dtype=np.uint8)
                    record_frame = record_frame.reshape((FrameHead.iHeight, FrameHead.iWidth,
                                          1 if FrameHead.uiMediaType == mvsdk.CAMERA_MEDIA_TYPE_MONO8 else 3))
                    video_writer.write(record_frame)
            # ========================================================

            # Windows下翻转
            if platform.system() == "Windows":
                mvsdk.CameraFlipFrameBuffer(pFrameBuffer, FrameHead, 1)

            # 4. 转换为numpy数组用于显示
            frame_data = (mvsdk.c_ubyte * FrameHead.uBytes).from_address(pFrameBuffer)
            frame = np.frombuffer(frame_data, dtype=np.uint8)
            frame = frame.reshape((FrameHead.iHeight, FrameHead.iWidth,
                                  1 if FrameHead.uiMediaType == mvsdk.CAMERA_MEDIA_TYPE_MONO8 else 3))

            # 缩放显示
            display_frame = cv2.resize(frame, DISPLAY_SIZE, interpolation=cv2.INTER_LINEAR)
            
            # 计算帧率
            fps_counter += 1
            if time.time() - fps_start_time >= 1.0:
                current_fps = fps_counter / (time.time() - fps_start_time)
                fps_counter = 0
                fps_start_time = time.time()
            
            # 显示状态
            fps_text = f"FPS: {current_fps:.1f}"
            cv2.putText(display_frame, fps_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            
            if is_recording:
                mode_text = "REC (SDK)" if use_sdk_record else "REC (CV2)"
                cv2.putText(display_frame, mode_text, (DISPLAY_SIZE[0]-180, 30), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                cv2.circle(display_frame, (DISPLAY_SIZE[0]-190, 20), 8, (0, 0, 255), -1)

            cv2.imshow("Press q:Quit, s:Record, e:Stop", display_frame)

            key = cv2.waitKey(1) & 0xFF
            
            # ==================== 控制逻辑 ====================
            if key == ord('s'):
                if not is_recording:
                    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                    rec_fps = int(current_fps) if current_fps > 0 else 25
                    
                    # 优先尝试 SDK 录像
                    output_filename_sdk = f"rec_sdk_{timestamp}.avi"
                    # 参数：1表示MSCV压缩(仅Windows)，80是质量
                    err = mvsdk.CameraInitRecord(hCamera, 1, output_filename_sdk, 1, 80, rec_fps)
                    
                    if err == 0:
                        # SDK 录像初始化成功
                        is_recording = True
                        use_sdk_record = True
                        print(f"✅ SDK录像启动成功: {output_filename_sdk}")
                    else:
                        # SDK 录像失败（如Linux返回-4），回退到 OpenCV
                        print(f"⚠️ SDK录像初始化失败 (Err: {err})，切换至 OpenCV 录像模式...")
                        
                        output_filename_cv = f"rec_cv_{timestamp}.mp4"
                        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
                        # 使用相机原始分辨率
                        video_writer = cv2.VideoWriter(output_filename_cv, fourcc, rec_fps, 
                                                     (FrameHead.iWidth, FrameHead.iHeight))
                        
                        if video_writer.isOpened():
                            is_recording = True
                            use_sdk_record = False
                            print(f"✅ OpenCV录像启动成功: {output_filename_cv}")
                        else:
                            print("❌ OpenCV录像启动失败！")

            elif key == ord('e'):
                if is_recording:
                    if use_sdk_record:
                        mvsdk.CameraStopRecord(hCamera)
                    else:
                        if video_writer is not None:
                            video_writer.release()
                            video_writer = None
                    
                    is_recording = False
                    print("⏹️ 录像已停止")

        except mvsdk.CameraException as e:
            if e.error_code != mvsdk.CAMERA_STATUS_TIME_OUT:
                print("CameraGetImageBuffer failed({}): {}".format(e.error_code, e.message))

    # 清理
    if is_recording:
        if use_sdk_record:
            mvsdk.CameraStopRecord(hCamera)
        elif video_writer is not None:
            video_writer.release()
    
    mvsdk.CameraUnInit(hCamera)
    mvsdk.CameraAlignFree(pFrameBuffer)

def main():
    try:
        main_loop()
    finally:
        cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
